"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var jsonpath_1 = __importDefault(require("jsonpath"));
var pg_query_emscripten_1 = __importDefault(require("pg-query-emscripten"));
var ramda_1 = require("ramda");
function parseSelectStmt(selectAst, // Change the type to match the AST structure
defaultSchema, aliases) {
    if (selectAst.larg && selectAst.rarg) {
        // This is a UNION, INTERSECT, or EXCEPT operation
        return __spreadArray(__spreadArray([], parseSelectStmt(selectAst.larg.SelectStmt, defaultSchema, aliases), true), parseSelectStmt(selectAst.rarg.SelectStmt, defaultSchema, aliases), true);
    }
    var viewReferences = [];
    selectAst.fromClause.forEach(function (fromClause) {
        var fromTable = fromClause.RangeVar;
        var selectTargets = jsonpath_1.default.query(selectAst, "$.targetList[*].ResTarget");
        selectTargets.forEach(function (selectTarget) {
            var _a;
            var fields = jsonpath_1.default.query(selectTarget, "$.val[*].fields[*].String.str");
            var sourceTable = fromTable === null || fromTable === void 0 ? void 0 : fromTable.relname;
            var sourceSchema = fromTable === null || fromTable === void 0 ? void 0 : fromTable.schemaname;
            if (fields.length === 2) {
                var tableRel = fields[0];
                if (tableRel in aliases) {
                    sourceTable = aliases[tableRel].table;
                    sourceSchema = (_a = aliases[tableRel].schema) !== null && _a !== void 0 ? _a : sourceSchema;
                }
                else {
                    sourceTable = tableRel;
                }
            }
            var sourceColumn = (0, ramda_1.last)(fields);
            var viewReference = {
                viewColumn: selectTarget.name || (0, ramda_1.last)(fields),
                source: sourceTable && sourceColumn
                    ? {
                        schema: sourceSchema !== null && sourceSchema !== void 0 ? sourceSchema : defaultSchema,
                        table: sourceTable,
                        column: (0, ramda_1.last)(fields),
                    }
                    : undefined,
            };
            viewReferences.push(viewReference);
        });
    });
    return viewReferences;
}
function parseViewDefinition(selectStatement, defaultSchema) {
    var _a, _b, _c, _d;
    var ast = pg_query_emscripten_1.default.parse(selectStatement).parse_tree[0];
    var selectAst = (_b = (_a = ast.RawStmt) === null || _a === void 0 ? void 0 : _a.stmt) === null || _b === void 0 ? void 0 : _b.SelectStmt;
    if (!selectAst) {
        throw new Error("The string '".concat(selectStatement, "' doesn't parse as a select statement."));
    }
    var aliasDefinitions = jsonpath_1.default.query(ast, "$.RawStmt.stmt.SelectStmt.fromClause..[?(@.alias)]");
    var aliases = Object.fromEntries(aliasDefinitions.map(function (_a) {
        var schemaname = _a.schemaname, relname = _a.relname, alias = _a.alias;
        return [
            alias.Alias.aliasname,
            { schema: schemaname, table: relname },
        ];
    }));
    var withClauses = ((_d = (_c = selectAst.withClause) === null || _c === void 0 ? void 0 : _c.WithClause) === null || _d === void 0 ? void 0 : _d.ctes) || [];
    var cteAliases = {};
    for (var _i = 0, withClauses_1 = withClauses; _i < withClauses_1.length; _i++) {
        var cte = withClauses_1[_i];
        if (cte.CommonTableExpr) {
            var alias = cte.CommonTableExpr.ctename;
            var cteQuery = cte.CommonTableExpr.ctequery.SelectStmt;
            if (!cteQuery) {
                continue;
            }
            // Process the CTE query recursively
            var cteAlias = parseSelectStmt(cteQuery, defaultSchema, aliases);
            cteAliases[alias] = cteAlias;
        }
    }
    var primaryViewReferences = parseSelectStmt(selectAst, defaultSchema, aliases);
    var viewReferences = primaryViewReferences.map(function (viewReference) {
        var source = viewReference.source;
        return source && source.table in cteAliases
            ? cteAliases[source.table].find(function (cteViewReference) {
                return cteViewReference.viewColumn === viewReference.viewColumn;
            })
            : viewReference;
    });
    return viewReferences;
}
exports.default = parseViewDefinition;
