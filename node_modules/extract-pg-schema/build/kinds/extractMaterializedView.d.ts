import type { Knex } from "knex";
import type InformationSchemaColumn from "../information_schema/InformationSchemaColumn";
import type InformationSchemaView from "../information_schema/InformationSchemaView";
import type { ColumnReference, Index } from "./extractTable";
import type PgType from "./PgType";
/**
 * Column type in a materialized view.
 */
export type MaterializedViewColumnType = {
    /**
     * Qualified name of the type.
     */
    fullName: string;
    /**
     * Kind of the type.
     */
    kind: "base" | "range" | "domain" | "composite" | "enum";
};
/**
 * Column in a materialized view.
 */
export interface MaterializedViewColumn {
    /**
     * Column name.
     */
    name: string;
    /**
     * Expanded type name. If the type is an array, brackets will be appended
     * to the type name.
     */
    expandedType: string;
    /**
     * Type information.
     */
    type: MaterializedViewColumnType;
    /**
     * Comment on the column.
     */
    comment: string | null;
    /**
     * Default value of the column.
     */
    defaultValue: any;
    /**
     * Whether the column is an array.
     */
    isArray: boolean;
    /**
     * Maximum length of the column.
     */
    maxLength: number | null;
    /**
     * Behavior of the generated column. "ALWAYS" if always generated,
     * "NEVER" if never generated, "BY DEFAULT" if generated when a value
     * is not provided.
     */
    generated: "ALWAYS" | "NEVER" | "BY DEFAULT";
    /**
     * Whether the column is updatable.
     */
    isUpdatable: boolean;
    /**
     * Whether the column is an identity column.
     */
    isIdentity: boolean;
    /**
     * Ordinal position of the column in the view. Starts from 1.
     */
    ordinalPosition: number;
    /**
     * This will contain a "link" to the source table or view and column,
     * if it can be determined.
     */
    source?: {
        schema: string;
        table: string;
        column: string;
    };
    /**
     * If views are resolved, this will contain the references from the source
     * column in the table that this view references. Note that if the source
     * is another view, that view in turn will be resolved if possible, leading
     * us to a table in the end.
     */
    references?: ColumnReference[];
    /** @deprecated use references instead */
    reference?: ColumnReference | null;
    /** @deprecated use TableDetails.indices instead */
    indices?: Index[];
    /**
     * Whether the column is nullable. This is only present if the view is
     * resolved.
     */
    isNullable?: boolean;
    /**
     * Whether the column is a primary key. This is only present if the view is
     * resolved.
     */
    isPrimaryKey?: boolean;
    /**
     * The Postgres information_schema views do not contain info about materialized views.
     * This value is the result of a query that matches the one for regular views.
     * Use with caution, not all fields are guaranteed to be meaningful and/or accurate.
     */
    fakeInformationSchemaValue: InformationSchemaColumn;
}
/**
 * Materialized view in a schema.
 */
export interface MaterializedViewDetails extends PgType<"materializedView"> {
    /**
     * The SQL definition of the view.
     */
    definition: string;
    /**
     * Columns in the materialized view.
     */
    columns: MaterializedViewColumn[];
    /**
     * The Postgres information_schema views do not contain info about materialized views.
     * This value is the result of a query that matches the one for regular views.
     * Use with caution, not all fields are guaranteed to be meaningful and/or accurate.
     */
    fakeInformationSchemaValue: InformationSchemaView;
}
declare const extractMaterializedView: (db: Knex, materializedView: PgType<"materializedView">) => Promise<MaterializedViewDetails>;
export default extractMaterializedView;
